<!DOCTYPE html>
<html>
    <head>
        <script src="/bjc-r/llab/loader.js"></script>
        <title>Basic File Input</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176402054-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176402054-1');
</script>
</head>
    <body>
        <p>
            In this section we will discuss how you can read files in Python. We'll also demo a common pattern in Python programming, where we first create "top level" scripts, that we later move into functions once we feel confident they are working. 
        </p>
        <p>
            To start, create a file called "word_analyzer.py" and open it in your favorite text editor. Once you've got it open, add the following code:
        </p>

    <pre><code>f = open("horse_ebooks.txt", "r")
print(f)
      </code></pre>
      <p>
        In Python, <code>open</code> is a reporter that takes two arguments. The first is the name of the file you want to open, and the second is a "mode", in this case "r" for "read". Don't worry about the details too much in this lab, you'll cover them in a later course. The <code>open</code> reporter reports a file object, which we then store in variable f using the <code>=</code> operator. What is a file object? You can think of it as a friend robot that knows how to read one specific file from our computer's hard drive. When we create a file object (using open), we're delegating the responsibility for reading exactly that one file to this object. We'll rely on this friend to get the data we need from the file.
      </p>
        Run this file and you should see something mysterious that looks something like:
      </p>

    <pre><code>$$ python word_analyzer.py
<_io.TextIOWrapper name='horse_ebooks.txt' mode='r' encoding='UTF-8'></code></pre>

 <p class="alert quoteBlue">
 Tip: Instead of typing out the entire filename for "word_analyzer.py", instead just type "python wo", then press tab, and your command line will autocomplete the filename. 
 </p>

    <p>Consider that mysterious stuff that got printed out by Python: <code><_io.TextIOWrapper name='horse_ebooks.txt' mode='r' encoding='UTF-8'></code> This is Python's way of printing out the file object. As a programmer, you don't really care (or understand) what this stuff means. It's like asking one of your friends for her DNA sequence instead of asking her to pass you the mashed potatoes. Instead, we want the file object to do its job and get the data from the file on our computer. To do this, modify your word_analyzer.py so that it reads as shown below:

    <pre><code>f = open("horse_ebooks.txt", "r")
text = f.read()
print(text)</code></pre>

    <p>
    Try running word_analyzer.py, and you should get a print out of the contents of the file "horse_ebooks.txt".
    </p>

    <pre><code>$$ python word_analyzer.py
Fruits and Vegetables and Vegetables on a Budget and Vegetables at a Store and Vegetables to Clean Fruit and Vegetables</code></pre>

    <p>If we look to the Python code, <code>f.read()</code> is the important part. <code>read</code> is a function that is built into every file object (just like <code>.append</code> is built into any list and <code>.join</code> is built into any string). Here, we're telling the file object to give us the information in the file for which it is responsible (horse_ebooks.txt). Note that this was not possible in Snap<em>!</em>, given the restrictions that our web browser places on the Snap<em>!</em> interpreter.
    </p> 

    <h3>Putting Our Code into a Nice Function</h3>

    <p>In Snap<em>!</em>, we saw that it makes sense to move code that does a specific task into a block. In this case, we're going to want to read files throughout the rest of this lab, so we will move our code into a function called <code>read_file</code>. We're doing this because if we want to read many files throughout the lab, we'd rather use a single function rather than have to rewrite our two lines of file-reading code every time. Modify your word_analyzer.py so that it reads as below. 
    </p>

    <pre><code>def read_file(filename):
    """Returns the text contained in file with given filename."""
    f = open(filename, "r")
    text = f.read()
    return text</code></pre>

    <p>You'll notice that we've done something strange, and have added an English description of what the function is supposed to do inside triple quotes. These triple quoted comments are very (!!) common in real world Python code, as it provides other programmers with an understanding of what your function is supposed to do.</p>

    <p>Recall that abstraction gives us two glorious advantages: detail hiding and generalization. We've now got a general function that can read any file, and when we read files we don't have to think about file objects or modes or any of that mysterious business. We first saw these principles in action in Snap<em>!</em>, but they'll be important to you as long as you're writing programs, and even beyond. 
    </p>

    </body>
</html>