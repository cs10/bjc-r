<!DOCTYPE html>
<html>
    <head>
        <script src="/bjc-r/llab/loader.js"></script>
        <title>HOFs in Python</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176402054-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176402054-1');
</script>
</head>
    <body>
        <h3>Map in Python</h3>
        <p>
            Just like in Snap<em>!</em>, Python allows us to operate on all of the items of a list by using Higher Order Functions (HOFs).  In python we can perform a map operation that squares all of the numbers in a list by using the following syntax:
        </p>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> my_list = [1, 2, 3]
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/set_my_list_snap.png"/>
                </td>
            </tr>
        </table>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> def square(x):
...    return x * x
>>> map(square, my_list)
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/snap_map_square.png"/>
                </td>
            </tr>
        </table>

        <p>
            Above you can see that the python code is very similar to the Snap<em>!</em> code.  Instead of having a multiply function with two blanks, as in the Snap<em>!</em> version of map, we first define a <code>square</code> function and pass it as an argument to the map function. We could also create an <a href="https://docs.google.com/presentation/d/1TwO63UECd9I4ufKDYUj9LDFT6RrDOtFQlbbcC9oBebE/pub?start=false&loop=false&delayms=3000&slide=id.gd1cee3eda_1_361">anonymous function</a> by using the <code>lambda</code> keyword, which acts a lot like the ringify command in Snap! We won't use <code>lambda</code> in this lab, but you'll see it plenty in 61A.

            <p>The <code>map</code> function in Python is actually not used very often. Instead, a closely related construct called a <b>list comprehension</b> is often used instead. An example is given below.

        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> my_list = [1, 2, 3]
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/set_my_list_snap.png"/>
                </td>
            </tr>
        </table>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> [x * x for x in my_list]                          
[1, 4, 9]    
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/snap_map_square.png"/>
                </td>
            </tr>
        </table>
        
        <p>
            <code>[x * x for x in my_list]</code> may look very strange at first, but once you've used this idea a few times, you'll realize it's quite powerful and easy to use. As before, you'll see that the python code shown is still fairly similar to the Snap! code. The differences are:
        </p>
        <p><ul>
            <li>
            Instead of having a multiply function with two blanks, we have <code>x * x</code> and we then specify that <code>x in my_list</code>.  
            </li>
            <li>Instead of explicitly calling the <code>map</code> function we are now using a special purpose syntax used specifically for mapping functions over lists.
            </li>
        </p>
            The net result is exactly the same: We multiply each element of <code>my_list</code> by itself, producing the effect of squaring each number. And like the <code>map</code> function, we produce a new list without changing the original list.
        </p>
        <p>
            The syntax for a <b>list comprehension</b> is as follows:
        <p><pre><code>
>>> [function(x) for x in my_list]
        </code></pre></p>
        <p>This syntax can be confusing at first because it looks like we're writing a bunch of code on one line inside of a list. Don't be fooled! Again, list comprehensions look weird, but they'll make lots of sense after you use them.
        </p>

        <h3>Keep in Python</h3>
        <p>
            In Python, the keep function is called <code>filter</code>. However, in practice, most people use list comprehensions, so we will not show any examples of using <code>filter</code>.
        </p>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> my_list = [1, 1, 2, 3, 5, 9]
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/longer_my_list.png"/>
                </td>
            </tr>
        </table>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> [x for x in my_list if x < 3]
[1, 1, 2]
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/keep_less_than3.png"/>
                </td>
            </tr>
        </table>
        <p>
            Or more generally, if we want to keep only items corresponding to some predicate, we'd use the following. Keep in mind that a predicate is simply a function that returns <code>True</code> or <code>False</code>.
        </p>
        <p><pre><code>
>>> [x for x in my_list if predicate(x)]
        </code></pre></p>
        <h3>Using Map and Keep Together</h3>
        <p>
            List Comprehensions can be used to perform map and keep at the same time. We've also seen how to do this in Snap<em>!</em>, as shown to the right. Observe that the list comprehension is more concise.
        </p>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> my_list = [1, 1, 2, 3, 5, 9]
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/longer_my_list.png"/>
                </td>
            </tr>
        </table>
        <table style="width:80%">
            <tr>
                <td>
                    <pre><code>
>>> [x + 5 for x in my_list if x <  3] 
[6, 6, 7]
                    </code></pre>
                </td>
                <td>
                    <img src="/bjc-r/img/python/map_with_keep.png"/>
                </td>
            </tr>
        </table>
        <h3>Exercise 3.1: Substitute Base</h3>
        <p>
            Write the helper function <code>substitute_base</code> that takes as input a string representing a DNA sequence, a base to be substituted (old), and a base that is to take the place of the base being substituted (new).  Old and New could be any letter, so make sure to keep your code general! This function should return a string with the proper base substituted:
        </p>
        <p><pre><code>
>>> substitute_base("AAGTTAGTCA", "A", "C")
"CCGTTCGTCG"
        </code></pre></p>
        <h3>Exercise 3.2: Substitute Sequences</h3>
        <p>
            Now imagine that we have a list of DNA sequences and we want to make a base substitution in all of them.  Write the function <code>substitute_sequences</code> that takes as input a list of strings representing DNA sequences, a base to be substituted (old), and a base that is to take the place of the base being substituted (new).  This function should return a list of DNA sequences with the proper base substituted in each sequence (make sure to use list comprehensions or HOFs (<code>filter</code>, <code>map</code>) here):
        </p>
        <p><pre><code>
>>> sequences = ["AAGTTAGTCA", "CTCGAGTCCGAAAGC", "AAGTTCCGACTG"]
>>> substitue_sequence(sequences, "A", "C")
["CCGTTCGTCC", "CTCGCGTCCGCCCGC", CCGTTCCGCTG"]
        </code></pre></p>
    </body>
    <p class="alert quoteGreen">
        You can test these functions using the same command as in previous exercises, just replace the function number with either 3.1 or 3.2
    </p>
</html>