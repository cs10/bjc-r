<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<script src="/bjc-r/llab/loader.js"></script>
		<title>Term 1 Programming Project Teaching Guide</title>
	</head>

	<body>
		<h2>Programming Project</h2>
		<p>The purpose of this project is to offer students an opportunity to be creative with the ideas they have been learning so far in this course and to prepare students for the requirements of the <a href="http://media.collegeboard.com/digitalServices/pdf/ap/ap-computer-science-principles-performance-assessment.pdf" target="_blank">AP Create Task</a>. As a result, the structure of the task is rather rigid&mdash;particularly the submission requirements. However, the open-ended nature of the programming element still allows for significant creativity.</p>
        <p>There are a variety of project ideas offered for students on the first lab page. To foster creativity in your students, encourage students to make adaptation to the suggested projects or to design their own. <strong>This project should be a chance for students to experience the beauty and joy of computing.</strong></p> 
		

		<h3>Prepare:</h3>
		<div>
			<ul>
				<li>Review the requirements of the <a href="http://media.collegeboard.com/digitalServices/pdf/ap/ap-computer-science-principles-performance-assessment.pdf" target="_blank">AP Create Task</a>.</li>
                <li>Collect and prepare to present any additional suggestions you may have for student projects.</li>
			</ul>
		</div>


		<div class="sidenoteBig">
			<strong>Looking Ahead</strong>
			<ul>
				<li>The requirements of the programs (demonstrating abstraction and algorithms), the submission requirements (a PDF and a video), and the written assignment prompts are all designed to preview the constraints of the AP Create Task. In the actual Create Task, students will be asked to meet each of these requirements both as a team and again individually.</li>
			</ul>
		</div>
        <h3>Students will:</h3>
		<div>
			<ul>
				<li>Select and develop a team project demonstrating both abstraction and algorithms</li>
                <li>Submit a PDF of their code and a video of their team program</li>
                <li>Write a collaborative reflection on their program</li>
				<!--<li>Select and develop an <em>individual</em> project demonstrating both abstraction and algorithms</li>
                <li>Submit a PDF of their code and a video of their <em>individual</em> program</li>
                <li>Write an <em>individual</em> reflection on their program <em>and team programming experience</em></li>-->
			</ul>
		</div> 
			  
		
		<h3>As a Class:</h3>
		<div>
            <ul>
            	<li>...</li>
            </ul>
        </div>

		<div class="todo">Any ideas for these two sections?</div>

        <div class="commentBig">Are we still using this heading ("Look For") or have we completely switched over to "Tips"?</div>
		<h3>Look For:</h3>
		<div>
            <ul>
            	<li>...</li>
            </ul>
        </div>
			
			
        
        <h3>Correlation with AP CS Principles Framework</h3>
		<div class="apStandards">
			<h4>Computational Thinking Practices:</h4>
			<ul>
                <li><strong>P2 Creating Computational Artifacts</strong> Create an artifact with a practical, personal, or societal intent.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Select appropriate techniques to develop a computational artifact.</li>
                <li><strong>P2 Creating Computational Artifacts</strong> Use appropriate algorithmic and information management principles.</li>
                <li><strong>P3 Abstracting</strong> Explain how abstractions are used in computation or modeling.</li>
                <li><strong>P3 Abstracting</strong> Identify abstractions.</li>
                <li><strong>P5 Communicating</strong> Describe computation with accurate and precise language, notations, or visualizations.</li>
                <li><strong>P5 Communicating</strong> Summarize the purpose of a computational artifact.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in solving a computational problem.</li>
                <li><strong>P6 Collaborating</strong> Collaborate with another student in producing an artifact.</li>
                <li><strong>P6 Collaborating</strong> Share the workload by providing individual contributions to an overall collaborative effort.</li>
                <li><strong>P6 Collaborating</strong> Foster a constructive, collaborative climate by resolving conflicts and facilitating the contributions of a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Exchange knowledge and feedback with a partner or team member.</li>
                <li><strong>P6 Collaborating</strong> Review and revise their work as needed to create a high-quality artifact.</li>
			</ul>
			<h4>Essential Knowledge:</h4>
			<div class="todo">Any suggestions on what to do here (other than to read through them all in detail and remove any that don't quite apply)? --MF</div>
			<ul>
                <li><strong>EK1.1.1A</strong> A creative process in the development of a computational artifact can include, but is not limited to, employing nontraditional, nonprescribed techniques; the use of novel combinations of artifacts, tools, and techniques; and the exploration of personal curiosities.</li>
                <li><strong>EK1.1.1B</strong> Creating computational artifacts employs an iterative and often exploratory process to translate ideas into tangible form.</li>
                <li><strong>EK1.2.2B</strong> A creative development process for creating computational artifacts can be used to solve problems when traditional or prescribed computing techniques are not effective.</li>
                <li><strong>EK1.2.3A</strong> Creating computational artifacts can be done by combining and modifying existing artifacts or by creating new artifacts.</li>
                <li><strong>EK1.2.3B</strong> Computation facilitates the creation and modification of computational artifacts with enhanced detail and precision.</li>
                <li><strong>EK1.2.3C</strong> Combining or modifying existing artifacts can show personal expression of ideas.</li>
                <li><strong>EK1.2.4A</strong> A collaboratively created computational artifact reflects effort by more than one person.</li>
                <li><strong>EK1.2.4C</strong> Effective collaborative teams practice interpersonal communication, consensus building, conflict resolution, and negotiation.</li>
                <li><strong>EK1.2.4D</strong> Effective collaboration strategies enhance performance.</li>
                <li><strong>EK1.2.4E</strong> Collaboration facilitates the application of multiple perspectives (including sociocultural perspectives) and diverse talents and skills in developing computational artifacts.</li>
                <li><strong>EK1.2.4F</strong> A collaboratively created computational artifact can reflect personal expressions of ideas.</li>
                <li><strong>EK1.2.5B</strong> A computational artifact may have weaknesses, mistakes, or errors depending on the type of artifact.</li>
                <li><strong>EK2.2.1A</strong> The process of developing an abstraction involves removing detail and generalizing functionality.</li>
                <li><strong>EK2.2.1B</strong> An abstraction extracts common features from specific examples in order to generalize concepts.</li>
                <li><strong>EK2.2.1C</strong> An abstraction generalizes functionality with input parameters that allow software reuse.</li>
                <li><strong>EK2.2.2A</strong> Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.</li>
                <li><strong>EK2.2.2B</strong> Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.</li>
                <li><strong>EK4.1.1A</strong> Sequencing, selection, and iteration are building blocks of algorithms.</li>
                <li><strong>EK4.1.1B</strong> Sequencing is the application of each step of an algorithm in the order in which the statements are given.</li>
                <li><strong>EK4.1.1C</strong> Selection uses a Boolean condition to determine which of two parts of an algorithm is used.</li>
                <li><strong>EK4.1.1D</strong> Iteration is the repetition of part of an algorithm until a condition is met or for a specified number of times.</li>
                <li><strong>EK4.1.1E</strong> Algorithms can be combined to make new algorithms.</li>
                <li><strong>EK4.1.1F</strong> Using existing correct algorithms as building blocks for constructing a new algorithm helps ensure the new algorithm is correct.</li>
                <li><strong>EK4.1.1G</strong> Knowledge of standard algorithms can help in constructing new algorithms.</li>
                <li><strong>EK4.1.1H</strong> Different algorithms can be developed to solve the same problem.</li>
                <li><strong>EK4.1.1I</strong> Developing a new algorithm to solve a problem can yield insight into the problem.</li>
                <li><strong>EK4.1.2A</strong> Languages for algorithms include natural language, pseudocode, and visual and textual programming languages.</li>
                <li><strong>EK4.1.2B</strong> Natural language and pseudocode describe algorithms so that humans can understand them.</li>
                <li><strong>EK4.1.2C</strong> Algorithms described in programming languages can be executed on a computer.</li>
                <li><strong>EK4.1.2D</strong> Different languages are better suited for expressing different algorithms.</li>
                <li><strong>EK4.1.2E</strong> Some programming languages are designed for specific domains and are better for expressing algorithms in those domains.</li>
                <li><strong>EK4.1.2F</strong> The language used to express an algorithm can affect characteristics such as clarity or readability but not whether an algorithmic solution exists.</li>
                <li><strong>EK4.1.2G</strong> Every algorithm can be constructed using only sequencing, selection, and iteration.</li>
                <li><strong>EK4.1.2H</strong> Nearly all programming languages are equivalent in terms of being able to express any algorithm.</li>
                <li><strong>EK4.1.2I</strong> Clarity and readability are important considerations when expressing an algorithm in a language.</li>
                <li><strong>EK5.1.1A</strong> Programs are developed and used in a variety of ways by a wide range of people depending on the goals of the programmer.</li>
                <li><strong>EK5.1.1B</strong> Programs developed for creative expression, to satisfy personal curiosity, or to create new knowledge may have visual, audible, or tactile inputs and outputs.</li>
                <li><strong>EK5.1.1C</strong> Programs developed for creative expression, to satisfy personal curiosity, or to create new knowledge may be developed with different standards or methods than programs developed for widespread distribution.</li>
                <li><strong>EK5.1.1D</strong> Additional desired outcomes may be realized independently of the original purpose of the program.</li>
                <li><strong>EK5.1.1E</strong> A computer program or the results of running a program may be rapidly shared with a large number of users and can have widespread impact on individuals, organizations, and society.</li>
                <li><strong>EK5.1.1F</strong> Advances in computing have generated and increased creativity in other fields.</li>
                <li><strong>EK5.1.2A</strong> An iterative process of program development helps in developing a correct program to solve problems.</li>
                <li><strong>EK5.1.2B</strong> Developing correct program components and then combining them helps in creating correct programs.</li>
                <li><strong>EK5.1.2C</strong> Incrementally adding tested program segments to correct working programs helps create large correct programs.</li>
                <li><strong>EK5.1.2D</strong> Program documentation helps programmers develop and maintain correct programs to efficiently solve problems.</li>
                <li><strong>EK5.1.2E</strong> Documentation about program components, such as blocks and procedures, helps in developing and maintaining programs.</li>
                <li><strong>EK5.1.2F</strong> Documentation helps in developing and maintaining programs when working individually or in collaborative programming environments.</li>
                <li><strong>EK5.1.2G</strong> Program development includes identifying programmer and user concerns that affect the solution to problems.</li>
                <li><strong>EK5.1.2H</strong> Consultation and communication with program users is an important aspect of program development to solve problems.</li>
                <li><strong>EK5.1.2I</strong> A programmer’s knowledge and skill affects how a program is developed and how it is used to solve a problem.</li>
                <li><strong>EK5.1.2J</strong> A programmer designs, implements, tests, debugs, and maintains programs when solving problems.</li>
                <li><strong>EK5.1.3A</strong> Collaboration can decrease the size and complexity of tasks required of individual programmers.</li>
                <li><strong>EK5.1.3B</strong> Collaboration facilitates multiple perspectives in developing ideas for solving problems by programming.</li>
                <li><strong>EK5.1.3C</strong> Collaboration in the iterative development of a program requires different skills than developing a program alone.</li>
                <li><strong>EK5.1.3D</strong> Collaboration can make it easier to find and correct errors when developing programs.</li>
                <li><strong>EK5.1.3E</strong> Collaboration facilitates developing program components independently.</li>
                <li><strong>EK5.1.3F</strong> Effective communication between participants is required for successful collaboration when developing programs.</li>
                <li><strong>EK5.2.1A</strong> Algorithms are implemented using program instructions that are processed during program execution.</li>
                <li><strong>EK5.2.1B</strong> Program instructions are executed sequentially.</li>
                <li><strong>EK5.2.1C</strong> Program instructions may involve variables that are initialized and updated, read, and written.</li>
                <li><strong>EK5.2.1D</strong> An understanding of instructions processing and program execution is useful for programming.</li>
                <li><strong>EK5.2.1E</strong> Program execution automates processes.</li>
                <li><strong>EK5.2.1G</strong> A process may execute by itself or with other processes.</li>
                <li><strong>EK5.2.1J</strong> Simple algorithms can solve a large set of problems when automated.</li>
                <li><strong>EK5.2.1K</strong> Improvements in algorithms, hardware, and software increase the kinds of problems and the size of problems solvable by programming.</li>
                <li><strong>EK5.3.1A</strong> Procedures are reusable programming abstractions.</li>
                <li><strong>EK5.3.1B</strong> A procedure is a named grouping of programming instructions.</li>
                <li><strong>EK5.3.1C</strong> Procedures reduce the complexity of writing and maintaining programs.</li>
                <li><strong>EK5.3.1D</strong> Procedures have names and may have parameters and return values.</li>
                <li><strong>EK5.3.1E</strong> Parameterization can generalize a specific solution.</li>
                <li><strong>EK5.3.1F</strong> Parameters generalize a solution by allowing a procedure to be used instead of duplicated code.</li>
                <li><strong>EK5.3.1G</strong> Parameters provide different values as input to procedures when they are called in a program.</li>
                <li><strong>EK5.3.1H</strong> Data abstraction provides a means of separating behavior from implementation.</li>
                <li><strong>EK5.3.1I</strong> Strings and string operations, including concatenation and some form of substring, are common in many programs.</li>
                <li><strong>EK5.3.1J</strong> Integers and floating-point numbers are used in programs without requiring understanding of how they are implemented.</li>
                <li><strong>EK5.3.1K</strong> Lists and list operations, such as add, remove, and search, are common in many programs.</li>
                <li><strong>EK5.3.1L</strong> Using lists and procedures as abstractions in programming can result in programs that are easier to develop and maintain.</li>
                <li><strong>EK5.4.1A</strong> Program style can affect the determination of program correctness.</li>
                <li><strong>EK5.4.1B</strong> Duplicated code can make it harder to reason about a program.</li>
                <li><strong>EK5.4.1C</strong> Meaningful names for variables and procedures help people better understand programs.</li>
                <li><strong>EK5.4.1D</strong> Longer code blocks are harder to reason about than shorter code blocks in a program.</li>
                <li><strong>EK5.4.1E</strong> Locating and correcting errors in a program is called debugging the program.</li>
                <li><strong>EK5.4.1F</strong> Knowledge of what a program is supposed to do is required in order to find most program errors.</li>
                <li><strong>EK5.4.1G</strong> Examples of intended behavior on specific inputs help people understand what a program is supposed to do.</li>
                <li><strong>EK5.4.1H</strong> Visual displays (or different modalities) of program state can help in finding errors.</li>
                <li><strong>EK5.4.1I</strong> Programmers justify and explain a program’s correctness.</li>
                <li><strong>EK5.4.1J</strong> Justification can include a written explanation about how a program meets its specifications.</li>
                <li><strong>EK5.4.1K</strong> Correctness of a program depends on correctness of program components, including code blocks and procedures.</li>
                <li><strong>EK5.4.1L</strong> An explanation of a program helps people understand the functionality and purpose of it.</li>
                <li><strong>EK5.4.1M</strong> The functionality of a program is often described by how a user interacts with it.</li>
                <li><strong>EK5.4.1N</strong> The functionality of a program is best described at a high level by what the program does, not at the lower level of how the program statements work to accomplish this.</li>
                <li><strong>EK5.5.1C</strong> Real numbers are approximated by floating-point representations that do not necessarily have infinite precision.</li>
                <li><strong>EK5.5.1D</strong> Mathematical expressions using arithmetic operators are part of most programming languages.</li>
                <li><strong>EK5.5.1E</strong> Logical concepts and Boolean algebra are fundamental to programming.</li>
                <li><strong>EK5.5.1F</strong> Compound expressions using <em>and</em>, <em>or</em>, and <em>not</em> are part of most programming languages.</li>
                <li><strong>EK5.5.1G</strong> Intuitive and formal reasoning about program components using Boolean concepts helps in developing correct programs.</li>
                <li><strong>EK5.5.1H</strong> Computational methods may use lists and collections to solve problems.</li>
                <li><strong>EK5.5.1I</strong> Lists and other collections can be treated as abstract data types (ADTs) in developing programs.</li>
                <li><strong>EK5.5.1J</strong> Basic operations on collections include adding elements, removing elements, iterating over all elements, and determining whether an element is in a collection.</li>
			</ul>
		</div>			


	</body>
</html>
